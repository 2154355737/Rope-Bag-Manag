# ç»³åŒ…ç®¡ç†å™¨åç«¯é‡æ„æ–¹æ¡ˆ

## é¡¹ç›®æ¦‚è¿°

å½“å‰åç«¯é¡¹ç›®åŸºäº Rust + Actix-Web + SQLite æ„å»ºï¼Œè™½ç„¶åŠŸèƒ½å®Œæ•´ï¼Œä½†å­˜åœ¨å¤§é‡æ¶æ„å’Œä»£ç è´¨é‡é—®é¢˜ï¼Œå½±å“ç»´æŠ¤æ€§ã€å¯æ‰©å±•æ€§å’Œæ€§èƒ½ã€‚æœ¬æ–‡æ¡£è¯¦ç»†åˆ†æç°æœ‰é—®é¢˜å¹¶æä¾›ç³»ç»Ÿæ€§é‡æ„æ–¹æ¡ˆã€‚

## ğŸ” ç°æœ‰é—®é¢˜åˆ†æ

### 1. æ¶æ„å±‚é¢é—®é¢˜

#### 1.1 ä¾èµ–æ³¨å…¥æ··ä¹±
- **é—®é¢˜**: `main.rs` ä¸­æ‰‹åŠ¨åˆ›å»ºæ‰€æœ‰æœåŠ¡å®ä¾‹ï¼Œå¯¼è‡´ 400+ è¡Œçš„è‡ƒè‚¿ä»£ç 
- **å½±å“**: 
  - æœåŠ¡å¯åŠ¨å¤æ‚ï¼Œéš¾ä»¥ç»´æŠ¤
  - ä¾èµ–å…³ç³»ä¸æ¸…æ™°
  - å•å…ƒæµ‹è¯•å›°éš¾
  - æ— æ³•å®ç°ä¼˜é›…çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†

#### 1.2 å±‚æ¬¡ç»“æ„ä¸æ¸…æ™°
- **é—®é¢˜**: Repositoryã€Serviceã€Controller è¾¹ç•Œæ¨¡ç³Š
- **å½±å“**:
  - ä¸šåŠ¡é€»è¾‘åˆ†æ•£åœ¨ä¸åŒå±‚
  - ä»£ç é‡å¤ä¸¥é‡
  - èŒè´£ä¸æ˜ç¡®

#### 1.3 é”™è¯¯å¤„ç†ä¸ç»Ÿä¸€
- **é—®é¢˜**: å„æ¨¡å—ä½¿ç”¨ä¸åŒçš„é”™è¯¯å¤„ç†æ–¹å¼
- **å½±å“**:
  - é”™è¯¯ä¿¡æ¯ä¸ä¸€è‡´
  - è°ƒè¯•å›°éš¾
  - å®¢æˆ·ç«¯éš¾ä»¥å¤„ç†

### 2. æ•°æ®åº“è®¾è®¡é—®é¢˜

#### 2.1 è¡¨ç»“æ„æ··ä¹±
- **é—®é¢˜**: å­˜åœ¨å¤§é‡è¿ç§»æ–‡ä»¶ï¼Œè¡¨ç»“æ„ä¸ä¸€è‡´
- **å½±å“**:
  - æ•°æ®å®Œæ•´æ€§é—®é¢˜
  - æŸ¥è¯¢æ€§èƒ½ä½ä¸‹
  - ç»´æŠ¤å¤æ‚

#### 2.2 ç´¢å¼•ç¼ºå¤±
- **é—®é¢˜**: å…³é”®æŸ¥è¯¢å­—æ®µç¼ºå°‘ç´¢å¼•
- **å½±å“**:
  - æŸ¥è¯¢æ€§èƒ½å·®
  - é«˜å¹¶å‘ä¸‹æ•°æ®åº“å‹åŠ›å¤§

#### 2.3 å¤–é”®çº¦æŸä¸å®Œæ•´
- **é—®é¢˜**: éƒ¨åˆ†è¡¨ç¼ºå°‘å¤–é”®çº¦æŸ
- **å½±å“**:
  - æ•°æ®ä¸€è‡´æ€§æ— æ³•ä¿è¯
  - å¯èƒ½å‡ºç°è„æ•°æ®

### 3. ä»£ç è´¨é‡é—®é¢˜

#### 3.1 æ–‡ä»¶è¿‡å¤§
- **é—®é¢˜**: å•ä¸ªæ–‡ä»¶è¶…è¿‡ 1000+ è¡Œï¼ˆå¦‚ `admin.rs` 1728 è¡Œï¼‰
- **å½±å“**:
  - ä»£ç éš¾ä»¥ç†è§£å’Œç»´æŠ¤
  - åˆå¹¶å†²çªé¢‘ç¹
  - å•ä¸€èŒè´£åŸåˆ™è¿å

#### 3.2 é‡å¤ä»£ç ä¸¥é‡
- **é—®é¢˜**: ç›¸ä¼¼é€»è¾‘åœ¨å¤šä¸ªæœåŠ¡ä¸­é‡å¤å®ç°
- **å½±å“**:
  - ç»´æŠ¤æˆæœ¬é«˜
  - å®¹æ˜“å¼•å…¥ bug
  - ä¸åˆ©äºç»Ÿä¸€ä¿®æ”¹

#### 3.3 ç¡¬ç¼–ç ä¸¥é‡
- **é—®é¢˜**: é…ç½®ã€å¸¸é‡æ•£å¸ƒåœ¨ä»£ç å„å¤„
- **å½±å“**:
  - é…ç½®ç®¡ç†å›°éš¾
  - ç¯å¢ƒåˆ‡æ¢å¤æ‚
  - ä¸åˆ©äºéƒ¨ç½²

### 4. æ€§èƒ½é—®é¢˜

#### 4.1 æ•°æ®åº“è¿æ¥ç®¡ç†
- **é—®é¢˜**: æ¯ä¸ªè¯·æ±‚åˆ›å»ºæ–°è¿æ¥ï¼Œæ²¡æœ‰è¿æ¥æ± 
- **å½±å“**:
  - èµ„æºæµªè´¹
  - è¿æ¥å¼€é”€å¤§
  - å¹¶å‘æ€§èƒ½å·®

#### 4.2 ç¼“å­˜æœºåˆ¶ç¼ºå¤±
- **é—®é¢˜**: æ²¡æœ‰åˆç†çš„ç¼“å­˜ç­–ç•¥
- **å½±å“**:
  - é‡å¤æŸ¥è¯¢æ•°æ®åº“
  - å“åº”æ—¶é—´é•¿
  - æ•°æ®åº“å‹åŠ›å¤§

#### 4.3 SQL æŸ¥è¯¢æœªä¼˜åŒ–
- **é—®é¢˜**: å­˜åœ¨ N+1 æŸ¥è¯¢ã€ä¸å¿…è¦çš„å…³è”æŸ¥è¯¢
- **å½±å“**:
  - æŸ¥è¯¢æ€§èƒ½å·®
  - èµ„æºæ¶ˆè€—å¤§

## ğŸ¯ é‡æ„ç›®æ ‡

### 1. æŠ€æœ¯ç›®æ ‡
- **æ¶æ„æ¸…æ™°**: æ¸…æ™°çš„åˆ†å±‚æ¶æ„ï¼Œæ˜ç¡®çš„èŒè´£åˆ†ç¦»
- **ä»£ç ç®€æ´**: æ¶ˆé™¤é‡å¤ä»£ç ï¼Œæé«˜ä»£ç å¤ç”¨æ€§
- **æ€§èƒ½ä¼˜åŒ–**: æå‡æŸ¥è¯¢æ€§èƒ½ï¼Œä¼˜åŒ–èµ„æºä½¿ç”¨
- **å¯ç»´æŠ¤æ€§**: æ˜“äºç†è§£ã€ä¿®æ”¹å’Œæ‰©å±•çš„ä»£ç ç»“æ„
- **å¯æµ‹è¯•æ€§**: å®Œå–„çš„å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•

### 2. ä¸šåŠ¡ç›®æ ‡
- **åŠŸèƒ½å®Œæ•´**: ä¿æŒç°æœ‰æ‰€æœ‰åŠŸèƒ½ä¸å˜
- **æ¥å£å…¼å®¹**: å‰ç«¯æ— éœ€ä¿®æ”¹ï¼ŒAPI æ¥å£ä¿æŒå…¼å®¹
- **æ•°æ®å®‰å…¨**: ç¡®ä¿æ•°æ®è¿ç§»è¿‡ç¨‹ä¸­çš„å®Œæ•´æ€§å’Œå®‰å…¨æ€§

## ğŸ—ï¸ é‡æ„æ–¹æ¡ˆ

### é˜¶æ®µä¸€ï¼šæ¶æ„é‡ç»„ï¼ˆ2-3å‘¨ï¼‰

#### 1.1 ä¾èµ–æ³¨å…¥æ¡†æ¶é‡æ„

**ç›®æ ‡**: ä½¿ç”¨ Rust çš„ä¾èµ–æ³¨å…¥æ¨¡å¼ï¼Œç®€åŒ–æœåŠ¡ç®¡ç†

**å®æ–½æ–¹æ¡ˆ**:
```rust
// åˆ›å»ºåº”ç”¨çŠ¶æ€ç®¡ç†å™¨
pub struct AppState {
    pub services: ServiceContainer,
    pub config: Arc<Config>,
}

pub struct ServiceContainer {
    pub user_service: Arc<UserService>,
    pub package_service: Arc<PackageService>,
    pub auth_service: Arc<AuthService>,
    // ... å…¶ä»–æœåŠ¡
}

impl ServiceContainer {
    pub async fn new(config: &Config) -> Result<Self> {
        let db_pool = create_db_pool(&config.database_url).await?;
        
        // æŒ‰ä¾èµ–é¡ºåºåˆ›å»ºæœåŠ¡
        let user_repo = UserRepository::new(db_pool.clone());
        let package_repo = PackageRepository::new(db_pool.clone());
        
        let user_service = Arc::new(UserService::new(user_repo));
        let package_service = Arc::new(PackageService::new(package_repo, user_service.clone()));
        
        Ok(Self {
            user_service,
            package_service,
            // ...
        })
    }
}
```

#### 1.2 åˆ†å±‚æ¶æ„é‡æ„

**æ–°çš„ç›®å½•ç»“æ„**:
```
src/
â”œâ”€â”€ core/           # æ ¸å¿ƒä¸šåŠ¡é€»è¾‘
â”‚   â”œâ”€â”€ domain/     # é¢†åŸŸæ¨¡å‹
â”‚   â”œâ”€â”€ services/   # ä¸šåŠ¡æœåŠ¡
â”‚   â””â”€â”€ ports/      # æ¥å£å®šä¹‰
â”œâ”€â”€ infrastructure/ # åŸºç¡€è®¾æ–½
â”‚   â”œâ”€â”€ database/   # æ•°æ®åº“ç›¸å…³
â”‚   â”œâ”€â”€ cache/      # ç¼“å­˜å®ç°
â”‚   â”œâ”€â”€ storage/    # æ–‡ä»¶å­˜å‚¨
â”‚   â””â”€â”€ email/      # é‚®ä»¶æœåŠ¡
â”œâ”€â”€ api/           # API å±‚
â”‚   â”œâ”€â”€ handlers/   # è¯·æ±‚å¤„ç†å™¨
â”‚   â”œâ”€â”€ middleware/ # ä¸­é—´ä»¶
â”‚   â””â”€â”€ routes/     # è·¯ç”±å®šä¹‰
â”œâ”€â”€ shared/        # å…±äº«ç»„ä»¶
â”‚   â”œâ”€â”€ errors/     # é”™è¯¯å®šä¹‰
â”‚   â”œâ”€â”€ utils/      # å·¥å…·å‡½æ•°
â”‚   â””â”€â”€ types/      # é€šç”¨ç±»å‹
â””â”€â”€ config/        # é…ç½®ç®¡ç†
```

#### 1.3 é”™è¯¯å¤„ç†ç»Ÿä¸€

**å®æ–½æ–¹æ¡ˆ**:
```rust
// ç»Ÿä¸€é”™è¯¯ç±»å‹
#[derive(Debug, thiserror::Error)]
pub enum AppError {
    #[error("æ•°æ®åº“é”™è¯¯: {0}")]
    Database(#[from] sqlx::Error),
    
    #[error("è®¤è¯é”™è¯¯: {0}")]
    Auth(String),
    
    #[error("ä¸šåŠ¡é€»è¾‘é”™è¯¯: {0}")]
    Business(String),
    
    #[error("å¤–éƒ¨æœåŠ¡é”™è¯¯: {0}")]
    External(String),
}

// ç»Ÿä¸€å“åº”æ ¼å¼
#[derive(Serialize)]
pub struct ApiResponse<T> {
    pub code: i32,
    pub message: String,
    pub data: Option<T>,
}

impl AppError {
    pub fn to_response<T>(&self) -> ApiResponse<T> {
        match self {
            AppError::Auth(_) => ApiResponse {
                code: 401,
                message: self.to_string(),
                data: None,
            },
            AppError::Business(_) => ApiResponse {
                code: 400,
                message: self.to_string(),
                data: None,
            },
            _ => ApiResponse {
                code: 500,
                message: "å†…éƒ¨æœåŠ¡å™¨é”™è¯¯".to_string(),
                data: None,
            },
        }
    }
}
```

### é˜¶æ®µäºŒï¼šæ•°æ®åº“é‡æ„ï¼ˆ1-2å‘¨ï¼‰

#### 2.1 æ•°æ®åº“ç»“æ„ä¼˜åŒ–

**æ ¸å¿ƒè¡¨é‡è®¾è®¡**:

```sql
-- ç”¨æˆ·è¡¨ (ä¼˜åŒ–å)
CREATE TABLE users (
    id BIGINT PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    nickname VARCHAR(100),
    avatar_url VARCHAR(500),
    bio TEXT,
    role user_role DEFAULT 'user' NOT NULL,
    status user_status DEFAULT 'active' NOT NULL,
    settings JSONB DEFAULT '{}',
    stats JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    -- ç´¢å¼•
    INDEX idx_users_email (email),
    INDEX idx_users_username (username),
    INDEX idx_users_role (role),
    INDEX idx_users_status (status),
    INDEX idx_users_created_at (created_at)
);

-- èµ„æºåŒ…è¡¨ (ä¼˜åŒ–å)
CREATE TABLE packages (
    id BIGINT PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    slug VARCHAR(200) UNIQUE NOT NULL, -- URLå‹å¥½çš„æ ‡è¯†ç¬¦
    author_id BIGINT NOT NULL,
    version VARCHAR(50) NOT NULL,
    description TEXT,
    readme TEXT,
    category_id BIGINT,
    tags JSONB DEFAULT '[]',
    metadata JSONB DEFAULT '{}', -- å­˜å‚¨æ–‡ä»¶ä¿¡æ¯ã€ä¾èµ–ç­‰
    stats JSONB DEFAULT '{}',    -- å­˜å‚¨ä¸‹è½½æ•°ã€ç‚¹èµæ•°ç­‰
    status package_status DEFAULT 'pending' NOT NULL,
    published_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    FOREIGN KEY (author_id) REFERENCES users(id),
    FOREIGN KEY (category_id) REFERENCES categories(id),
    
    -- ç´¢å¼•
    INDEX idx_packages_author_id (author_id),
    INDEX idx_packages_category_id (category_id),
    INDEX idx_packages_status (status),
    INDEX idx_packages_published_at (published_at),
    INDEX idx_packages_slug (slug),
    FULLTEXT INDEX idx_packages_search (name, description)
);

-- æ–‡ä»¶è¡¨ (æ–°å¢)
CREATE TABLE package_files (
    id BIGINT PRIMARY KEY,
    package_id BIGINT NOT NULL,
    filename VARCHAR(255) NOT NULL,
    file_path VARCHAR(500) NOT NULL,
    file_size BIGINT NOT NULL,
    mime_type VARCHAR(100),
    file_hash VARCHAR(64) NOT NULL, -- SHA256
    storage_type VARCHAR(20) DEFAULT 'local',
    storage_config JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    FOREIGN KEY (package_id) REFERENCES packages(id) ON DELETE CASCADE,
    
    INDEX idx_package_files_package_id (package_id),
    INDEX idx_package_files_hash (file_hash)
);
```

#### 2.2 æ•°æ®è¿ç§»ç­–ç•¥

**è¿ç§»æ­¥éª¤**:
1. **å¤‡ä»½ç°æœ‰æ•°æ®**: å®Œæ•´å¤‡ä»½å½“å‰æ•°æ®åº“
2. **å¹¶è¡Œè¿è¡Œ**: åœ¨æ–°ç»“æ„ä¸­åŒæ­¥å½“å‰æ•°æ®
3. **éªŒè¯æ•°æ®**: ç¡®ä¿æ•°æ®å®Œæ•´æ€§
4. **åˆ‡æ¢æœåŠ¡**: åŸå­æ€§åˆ‡æ¢åˆ°æ–°æ•°æ®åº“
5. **ç›‘æ§éªŒè¯**: ç›‘æ§æ–°ç³»ç»Ÿè¿è¡ŒçŠ¶å†µ

### é˜¶æ®µä¸‰ï¼šæœåŠ¡å±‚é‡æ„ï¼ˆ2-3å‘¨ï¼‰

#### 3.1 é¢†åŸŸæœåŠ¡è®¾è®¡

**ç”¨æˆ·æœåŠ¡é‡æ„**:
```rust
#[async_trait]
pub trait UserService: Send + Sync {
    async fn create_user(&self, request: CreateUserRequest) -> Result<User>;
    async fn authenticate(&self, credentials: LoginCredentials) -> Result<AuthToken>;
    async fn get_user_profile(&self, user_id: UserId) -> Result<UserProfile>;
    async fn update_profile(&self, user_id: UserId, updates: ProfileUpdates) -> Result<()>;
}

pub struct UserServiceImpl {
    user_repo: Arc<dyn UserRepository>,
    email_service: Arc<dyn EmailService>,
    cache: Arc<dyn CacheService>,
    event_bus: Arc<dyn EventBus>,
}

impl UserServiceImpl {
    pub fn new(
        user_repo: Arc<dyn UserRepository>,
        email_service: Arc<dyn EmailService>,
        cache: Arc<dyn CacheService>,
        event_bus: Arc<dyn EventBus>,
    ) -> Self {
        Self {
            user_repo,
            email_service,
            cache,
            event_bus,
        }
    }
}

#[async_trait]
impl UserService for UserServiceImpl {
    async fn create_user(&self, request: CreateUserRequest) -> Result<User> {
        // 1. éªŒè¯è¾“å…¥
        request.validate()?;
        
        // 2. æ£€æŸ¥é‡å¤
        if self.user_repo.exists_by_email(&request.email).await? {
            return Err(AppError::Business("é‚®ç®±å·²å­˜åœ¨".to_string()));
        }
        
        // 3. åˆ›å»ºç”¨æˆ·
        let user = User::new(request)?;
        let created_user = self.user_repo.create(user).await?;
        
        // 4. å‘é€äº‹ä»¶
        self.event_bus.publish(UserCreatedEvent {
            user_id: created_user.id,
            email: created_user.email.clone(),
        }).await?;
        
        // 5. æ¸…ç†ç¼“å­˜
        self.cache.invalidate_user_cache(created_user.id).await?;
        
        Ok(created_user)
    }
    
    // ... å…¶ä»–æ–¹æ³•å®ç°
}
```

#### 3.2 ä»“å‚¨å±‚ä¼˜åŒ–

**ä»“å‚¨æ¥å£æ ‡å‡†åŒ–**:
```rust
#[async_trait]
pub trait Repository<T, ID> {
    async fn find_by_id(&self, id: ID) -> Result<Option<T>>;
    async fn find_all(&self) -> Result<Vec<T>>;
    async fn create(&self, entity: T) -> Result<T>;
    async fn update(&self, entity: T) -> Result<T>;
    async fn delete(&self, id: ID) -> Result<()>;
}

#[async_trait]
pub trait UserRepository: Repository<User, UserId> {
    async fn find_by_email(&self, email: &str) -> Result<Option<User>>;
    async fn find_by_username(&self, username: &str) -> Result<Option<User>>;
    async fn exists_by_email(&self, email: &str) -> Result<bool>;
    async fn find_with_stats(&self, id: UserId) -> Result<Option<UserWithStats>>;
}
```

### é˜¶æ®µå››ï¼šAPIå±‚ä¼˜åŒ–ï¼ˆ1-2å‘¨ï¼‰

#### 4.1 ç»Ÿä¸€çš„è¯·æ±‚å¤„ç†

**æ ‡å‡†åŒ– Handler æ¨¡å¼**:
```rust
pub struct UserHandler {
    user_service: Arc<dyn UserService>,
    validator: Arc<dyn Validator>,
}

impl UserHandler {
    pub async fn create_user(
        &self,
        request: web::Json<CreateUserRequest>,
    ) -> Result<impl Responder> {
        // 1. éªŒè¯è¯·æ±‚
        self.validator.validate(&request)?;
        
        // 2. è°ƒç”¨æœåŠ¡
        let user = self.user_service.create_user(request.into_inner()).await?;
        
        // 3. è¿”å›å“åº”
        Ok(ApiResponse::success(UserResponse::from(user)))
    }
    
    pub async fn get_user_profile(
        &self,
        path: web::Path<UserId>,
        auth: AuthUser,
    ) -> Result<impl Responder> {
        let user_id = path.into_inner();
        
        // æƒé™æ£€æŸ¥
        if !auth.can_view_user(user_id) {
            return Err(AppError::Auth("æ— æƒé™æŸ¥çœ‹ç”¨æˆ·ä¿¡æ¯".to_string()));
        }
        
        let profile = self.user_service.get_user_profile(user_id).await?;
        Ok(ApiResponse::success(profile))
    }
}
```

#### 4.2 ä¸­é—´ä»¶ä¼˜åŒ–

**è®¤è¯ä¸­é—´ä»¶é‡æ„**:
```rust
pub struct AuthMiddleware {
    jwt_service: Arc<dyn JwtService>,
    user_service: Arc<dyn UserService>,
}

impl<S, B> Transform<S, ServiceRequest> for AuthMiddleware
where
    S: Service<ServiceRequest, Response = ServiceResponse<B>, Error = Error>,
    S::Future: 'static,
    B: 'static,
{
    type Response = ServiceResponse<B>;
    type Error = Error;
    type Transform = AuthMiddlewareService<S>;
    type InitError = ();
    type Future = Ready<Result<Self::Transform, Self::InitError>>;

    fn new_transform(&self, service: S) -> Self::Future {
        ready(Ok(AuthMiddlewareService {
            service,
            jwt_service: self.jwt_service.clone(),
            user_service: self.user_service.clone(),
        }))
    }
}
```

### é˜¶æ®µäº”ï¼šæ€§èƒ½ä¼˜åŒ–ï¼ˆ1-2å‘¨ï¼‰

#### 5.1 æ•°æ®åº“è¿æ¥æ± 

```rust
pub async fn create_db_pool(database_url: &str) -> Result<Pool<Sqlite>> {
    SqlitePoolOptions::new()
        .max_connections(20)
        .min_connections(5)
        .acquire_timeout(Duration::from_secs(30))
        .idle_timeout(Duration::from_secs(300))
        .max_lifetime(Duration::from_secs(1800))
        .connect(database_url)
        .await
        .map_err(|e| AppError::Database(e))
}
```

#### 5.2 ç¼“å­˜ç­–ç•¥

```rust
#[async_trait]
pub trait CacheService: Send + Sync {
    async fn get<T>(&self, key: &str) -> Result<Option<T>>
    where
        T: DeserializeOwned;
    
    async fn set<T>(&self, key: &str, value: &T, ttl: Duration) -> Result<()>
    where
        T: Serialize;
    
    async fn invalidate(&self, pattern: &str) -> Result<()>;
}

pub struct RedisCacheService {
    client: redis::Client,
}

impl RedisCacheService {
    pub fn new(redis_url: &str) -> Result<Self> {
        let client = redis::Client::open(redis_url)?;
        Ok(Self { client })
    }
}
```

#### 5.3 æŸ¥è¯¢ä¼˜åŒ–

**æ‰¹é‡æŸ¥è¯¢æ¨¡å¼**:
```rust
impl PackageRepository {
    pub async fn find_with_relations(&self, ids: &[PackageId]) -> Result<Vec<PackageWithRelations>> {
        // ä½¿ç”¨ JOIN è€Œä¸æ˜¯ N+1 æŸ¥è¯¢
        let query = r#"
            SELECT 
                p.*,
                u.username as author_name,
                u.avatar_url as author_avatar,
                c.name as category_name,
                COUNT(l.id) as like_count,
                COUNT(d.id) as download_count
            FROM packages p
            LEFT JOIN users u ON p.author_id = u.id
            LEFT JOIN categories c ON p.category_id = c.id
            LEFT JOIN package_likes l ON p.id = l.package_id
            LEFT JOIN package_downloads d ON p.id = d.package_id
            WHERE p.id = ANY($1)
            GROUP BY p.id, u.username, u.avatar_url, c.name
        "#;
        
        sqlx::query_as(query)
            .bind(ids)
            .fetch_all(&self.pool)
            .await
            .map_err(Into::into)
    }
}
```

## ğŸ“‹ å®æ–½è®¡åˆ’

### Phase 1: å‡†å¤‡é˜¶æ®µ (1å‘¨)
- [ ] å»ºç«‹å¼€å‘åˆ†æ”¯
- [ ] è®¾ç½®æµ‹è¯•ç¯å¢ƒ
- [ ] ç¼–å†™è¿ç§»æµ‹è¯•
- [ ] å‡†å¤‡ç›‘æ§æŒ‡æ ‡

### Phase 2: åŸºç¡€æ¶æ„ (3å‘¨)
- [ ] ä¾èµ–æ³¨å…¥æ¡†æ¶å®æ–½
- [ ] é”™è¯¯å¤„ç†ç»Ÿä¸€
- [ ] é…ç½®ç®¡ç†é‡æ„
- [ ] åŸºç¡€ä¸­é—´ä»¶é‡å†™

### Phase 3: æ•°æ®å±‚é‡æ„ (2å‘¨)
- [ ] æ–°æ•°æ®åº“è®¾è®¡
- [ ] æ•°æ®è¿ç§»è„šæœ¬
- [ ] Repository å±‚é‡å†™
- [ ] æ•°æ®ä¸€è‡´æ€§éªŒè¯

### Phase 4: ä¸šåŠ¡å±‚é‡æ„ (3å‘¨)
- [ ] é¢†åŸŸæœåŠ¡é‡å†™
- [ ] ä¸šåŠ¡é€»è¾‘è¿ç§»
- [ ] äº‹ä»¶ç³»ç»Ÿå®æ–½
- [ ] ç¼“å­˜é›†æˆ

### Phase 5: APIå±‚ä¼˜åŒ– (2å‘¨)
- [ ] Handler æ ‡å‡†åŒ–
- [ ] è·¯ç”±é‡ç»„
- [ ] ä¸­é—´ä»¶ä¼˜åŒ–
- [ ] æ–‡æ¡£æ›´æ–°

### Phase 6: æ€§èƒ½ä¼˜åŒ– (2å‘¨)
- [ ] æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
- [ ] ç¼“å­˜ç­–ç•¥å®æ–½
- [ ] è¿æ¥æ± é…ç½®
- [ ] æ€§èƒ½æµ‹è¯•

### Phase 7: æµ‹è¯•ä¸éƒ¨ç½² (1å‘¨)
- [ ] é›†æˆæµ‹è¯•
- [ ] æ€§èƒ½æµ‹è¯•
- [ ] å®‰å…¨æµ‹è¯•
- [ ] ç”Ÿäº§éƒ¨ç½²

## ğŸ‰ é¢„æœŸæ”¶ç›Š

### 1. å¼€å‘æ•ˆç‡æå‡
- **ä»£ç å¯è¯»æ€§**: æå‡ 80%ï¼Œæ–°å¼€å‘è€…ä¸Šæ‰‹æ—¶é—´å‡å°‘ 60%
- **å¼€å‘é€Ÿåº¦**: æ–°åŠŸèƒ½å¼€å‘æ•ˆç‡æå‡ 50%
- **Bugä¿®å¤**: é—®é¢˜å®šä½æ—¶é—´å‡å°‘ 70%

### 2. æ€§èƒ½æå‡
- **å“åº”æ—¶é—´**: API å“åº”æ—¶é—´å‡å°‘ 60%
- **å¹¶å‘èƒ½åŠ›**: æ”¯æŒå¹¶å‘æ•°æå‡ 5 å€
- **èµ„æºä½¿ç”¨**: å†…å­˜ä½¿ç”¨å‡å°‘ 40%ï¼ŒCPU ä½¿ç”¨å‡å°‘ 30%

### 3. ç»´æŠ¤æ€§æå‡
- **ä»£ç å¤æ‚åº¦**: å‡å°‘ 50% çš„é‡å¤ä»£ç 
- **æµ‹è¯•è¦†ç›–ç‡**: è¾¾åˆ° 85% ä»¥ä¸Š
- **æ–‡æ¡£å®Œæ•´æ€§**: 100% çš„ API æ–‡æ¡£è¦†ç›–

### 4. æ‰©å±•æ€§æå‡
- **æ¨¡å—åŒ–**: æ–°åŠŸèƒ½å¯ç‹¬ç«‹å¼€å‘å’Œéƒ¨ç½²
- **å¯é…ç½®æ€§**: æ”¯æŒå¤šç¯å¢ƒçµæ´»é…ç½®
- **ç›‘æ§èƒ½åŠ›**: å®Œå–„çš„æ—¥å¿—å’Œç›‘æ§ä½“ç³»

## ğŸš¨ é£é™©æ§åˆ¶

### 1. æŠ€æœ¯é£é™©
- **æ•°æ®ä¸¢å¤±**: å®Œæ•´å¤‡ä»½ + å¢é‡åŒæ­¥ + å›æ»šæ–¹æ¡ˆ
- **åŠŸèƒ½å›å½’**: å…¨é¢å›å½’æµ‹è¯• + è‡ªåŠ¨åŒ–æµ‹è¯•
- **æ€§èƒ½åŠ£åŒ–**: åŸºå‡†æµ‹è¯• + æ€§èƒ½ç›‘æ§

### 2. ä¸šåŠ¡é£é™©
- **æœåŠ¡ä¸­æ–­**: ç°åº¦å‘å¸ƒ + å¿«é€Ÿå›æ»š
- **ç”¨æˆ·ä½“éªŒ**: å‰ç«¯å…¼å®¹æ€§æµ‹è¯•
- **æ•°æ®ä¸€è‡´æ€§**: æ•°æ®æ ¡éªŒ + ä¸€è‡´æ€§æ£€æŸ¥

### 3. è¿›åº¦é£é™©
- **æ—¶é—´å»¶æœŸ**: åˆ†é˜¶æ®µäº¤ä»˜ + é‡Œç¨‹ç¢‘æ£€æŸ¥
- **èµ„æºä¸è¶³**: å›¢é˜ŸåŸ¹è®­ + æŠ€æœ¯æ”¯æŒ
- **éœ€æ±‚å˜æ›´**: å˜æ›´æ§åˆ¶æµç¨‹

## ğŸ“Š æˆåŠŸæŒ‡æ ‡

### 1. æŠ€æœ¯æŒ‡æ ‡
- API å“åº”æ—¶é—´ < 200ms (P95)
- æ•°æ®åº“æŸ¥è¯¢æ—¶é—´ < 50ms (P95)
- é”™è¯¯ç‡ < 0.1%
- ç³»ç»Ÿå¯ç”¨æ€§ > 99.9%

### 2. è´¨é‡æŒ‡æ ‡
- ä»£ç è¦†ç›–ç‡ > 85%
- å¤æ‚åº¦åˆ†æ•° < 10
- é‡å¤ä»£ç ç‡ < 5%
- æ–‡æ¡£è¦†ç›–ç‡ = 100%

### 3. ä¸šåŠ¡æŒ‡æ ‡
- åŠŸèƒ½å›å½’æµ‹è¯•é€šè¿‡ç‡ = 100%
- å‰ç«¯å…¼å®¹æ€§ = 100%
- æ•°æ®å®Œæ•´æ€§ = 100%
- ç”¨æˆ·æ»¡æ„åº¦ > 95%

---

**æ³¨æ„**: æœ¬é‡æ„æ–¹æ¡ˆä¿è¯åœ¨ä¸å½±å“å‰ç«¯ä½¿ç”¨çš„å‰æä¸‹ï¼Œå®ç°åç«¯æ¶æ„çš„å…¨é¢ä¼˜åŒ–ã€‚æ‰€æœ‰APIæ¥å£ä¿æŒå‘åå…¼å®¹ï¼Œæ•°æ®è¿ç§»è¿‡ç¨‹ç¡®ä¿é›¶æ•°æ®ä¸¢å¤±ã€‚ 