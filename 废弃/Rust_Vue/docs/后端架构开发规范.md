# ç»³åŒ…ç®¡ç†å™¨åç«¯æ¶æ„å¼€å‘è§„èŒƒ

## ğŸ“‹ ç›®å½•
1. [é¡¹ç›®æ¶æ„](#é¡¹ç›®æ¶æ„)
2. [ä»£ç ç»„ç»‡](#ä»£ç ç»„ç»‡)
3. [APIè®¾è®¡è§„èŒƒ](#apiè®¾è®¡è§„èŒƒ)
4. [æ•°æ®å±‚è®¾è®¡](#æ•°æ®å±‚è®¾è®¡)
5. [æœåŠ¡å±‚è®¾è®¡](#æœåŠ¡å±‚è®¾è®¡)
6. [ä¸­é—´ä»¶è®¾è®¡](#ä¸­é—´ä»¶è®¾è®¡)
7. [é”™è¯¯å¤„ç†](#é”™è¯¯å¤„ç†)
8. [æ—¥å¿—è§„èŒƒ](#æ—¥å¿—è§„èŒƒ)
9. [æµ‹è¯•è§„èŒƒ](#æµ‹è¯•è§„èŒƒ)
10. [éƒ¨ç½²è§„èŒƒ](#éƒ¨ç½²è§„èŒƒ)

## ğŸ—ï¸ é¡¹ç›®æ¶æ„

### æ•´ä½“æ¶æ„å›¾
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   API Layer     â”‚  â† HTTPè¯·æ±‚å¤„ç†
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Middleware     â”‚  â† è®¤è¯ã€é™æµã€æ—¥å¿—
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Service Layer  â”‚  â† ä¸šåŠ¡é€»è¾‘
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Repository      â”‚  â† æ•°æ®è®¿é—®
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Data Manager   â”‚  â† æ•°æ®ç®¡ç†
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ç›®å½•ç»“æ„
```
src/
â”œâ”€â”€ api/                    # APIå±‚
â”‚   â”œâ”€â”€ v1/                # APIç‰ˆæœ¬æ§åˆ¶
â”‚   â”‚   â”œâ”€â”€ auth.rs        # è®¤è¯ç›¸å…³API
â”‚   â”‚   â”œâ”€â”€ user.rs        # ç”¨æˆ·ç›¸å…³API
â”‚   â”‚   â”œâ”€â”€ admin.rs       # ç®¡ç†å‘˜API
â”‚   â”‚   â”œâ”€â”€ package.rs     # ç»³åŒ…ç›¸å…³API
â”‚   â”‚   â”œâ”€â”€ community.rs   # ç¤¾åŒºç›¸å…³API
â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â””â”€â”€ mod.rs
â”œâ”€â”€ core/                   # æ ¸å¿ƒä¸šåŠ¡é€»è¾‘
â”‚   â”œâ”€â”€ auth.rs            # è®¤è¯æ ¸å¿ƒ
â”‚   â”œâ”€â”€ user.rs            # ç”¨æˆ·æ ¸å¿ƒ
â”‚   â”œâ”€â”€ package.rs         # ç»³åŒ…æ ¸å¿ƒ
â”‚   â””â”€â”€ mod.rs
â”œâ”€â”€ services/              # æœåŠ¡å±‚
â”‚   â”œâ”€â”€ auth_service.rs    # è®¤è¯æœåŠ¡
â”‚   â”œâ”€â”€ user_service.rs    # ç”¨æˆ·æœåŠ¡
â”‚   â”œâ”€â”€ package_service.rs # ç»³åŒ…æœåŠ¡
â”‚   â””â”€â”€ mod.rs
â”œâ”€â”€ repositories/          # æ•°æ®è®¿é—®å±‚
â”‚   â”œâ”€â”€ user_repository.rs
â”‚   â”œâ”€â”€ package_repository.rs
â”‚   â””â”€â”€ mod.rs
â”œâ”€â”€ middleware/            # ä¸­é—´ä»¶
â”‚   â”œâ”€â”€ auth.rs           # è®¤è¯ä¸­é—´ä»¶
â”‚   â”œâ”€â”€ rate_limit.rs     # é™æµä¸­é—´ä»¶
â”‚   â”œâ”€â”€ logging.rs        # æ—¥å¿—ä¸­é—´ä»¶
â”‚   â””â”€â”€ mod.rs
â”œâ”€â”€ utils/                 # å·¥å…·ç±»
â”‚   â”œâ”€â”€ validation.rs     # éªŒè¯å·¥å…·
â”‚   â”œâ”€â”€ encryption.rs     # åŠ å¯†å·¥å…·
â”‚   â””â”€â”€ mod.rs
â”œâ”€â”€ types/                 # ç±»å‹å®šä¹‰
â”‚   â”œâ”€â”€ request.rs        # è¯·æ±‚ç±»å‹
â”‚   â”œâ”€â”€ response.rs       # å“åº”ç±»å‹
â”‚   â””â”€â”€ mod.rs
â”œâ”€â”€ models.rs             # æ•°æ®æ¨¡å‹
â”œâ”€â”€ config.rs             # é…ç½®ç®¡ç†
â”œâ”€â”€ data_manager.rs       # æ•°æ®ç®¡ç†å™¨
â””â”€â”€ main.rs               # åº”ç”¨å…¥å£
```

## ğŸ“ ä»£ç ç»„ç»‡

### æ¨¡å—å£°æ˜è§„èŒƒ
```rust
// æ¯ä¸ªæ¨¡å—éƒ½åº”è¯¥æœ‰æ¸…æ™°çš„mod.rsæ–‡ä»¶
pub mod auth;
pub mod user;
pub mod package;

pub use auth::*;
pub use user::*;
pub use package::*;
```

### å¯¼å…¥é¡ºåºè§„èŒƒ
```rust
// 1. æ ‡å‡†åº“
use std::sync::Arc;
use std::collections::HashMap;

// 2. ç¬¬ä¸‰æ–¹åº“
use actix_web::{web, HttpRequest, HttpResponse};
use serde::{Serialize, Deserialize};

// 3. æœ¬åœ°æ¨¡å—
use crate::models::User;
use crate::services::UserService;
use crate::types::response::ApiResponse;
```

## ğŸ¯ APIè®¾è®¡è§„èŒƒ

### RESTful APIè®¾è®¡
```rust
// ç”¨æˆ·èµ„æº
GET    /api/v1/users              # è·å–ç”¨æˆ·åˆ—è¡¨
GET    /api/v1/users/{id}         # è·å–å•ä¸ªç”¨æˆ·
POST   /api/v1/users              # åˆ›å»ºç”¨æˆ·
PUT    /api/v1/users/{id}         # æ›´æ–°ç”¨æˆ·
DELETE /api/v1/users/{id}         # åˆ é™¤ç”¨æˆ·

// ç”¨æˆ·æ“ä½œ
POST   /api/v1/users/{id}/sign-in # ç”¨æˆ·ç­¾åˆ°
POST   /api/v1/users/{id}/ban     # å°ç¦ç”¨æˆ·
POST   /api/v1/users/{id}/unban   # è§£å°ç”¨æˆ·
```

### è·¯ç”±é…ç½®è§„èŒƒ
```rust
pub fn configure_routes(cfg: &mut web::ServiceConfig) {
    cfg.service(
        web::scope("/users")
            .wrap(AuthMiddleware::require_auth())
            .route("", web::get().to(get_users))
            .route("", web::post().to(create_user))
            .route("/{id}", web::get().to(get_user))
            .route("/{id}", web::put().to(update_user))
            .route("/{id}", web::delete().to(delete_user))
    );
}
```

### è¯·æ±‚å‚æ•°éªŒè¯
```rust
#[derive(Debug, Serialize, Deserialize, Validate)]
pub struct CreateUserRequest {
    #[validate(length(min = 2, max = 20))]
    pub username: String,
    
    #[validate(length(min = 6, max = 100))]
    pub password: String,
    
    #[validate(email)]
    pub email: Option<String>,
}
```

## ğŸ“Š æ•°æ®å±‚è®¾è®¡

### Repositoryæ¨¡å¼
```rust
pub struct UserRepository {
    data_manager: Arc<DataManager>,
}

impl UserRepository {
    pub async fn get_all_users(&self) -> Result<Vec<User>> {
        self.data_manager.get_users()
    }
    
    pub async fn get_user_by_id(&self, id: u64) -> Result<Option<User>> {
        let users = self.data_manager.get_users()?;
        Ok(users.into_iter().find(|u| u.id == id))
    }
    
    pub async fn create_user(&self, user: &User) -> Result<()> {
        self.data_manager.add_user(user)
    }
}
```

### æ•°æ®æ¨¡å‹è§„èŒƒ
```rust
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct User {
    pub id: u64,
    pub username: String,
    pub password: String,
    pub role: UserRole,
    pub star: u32,
    pub online_status: OnlineStatus,
    pub ban_status: BanStatus,
    // ... å…¶ä»–å­—æ®µ
}

impl Default for User {
    fn default() -> Self {
        Self {
            id: 0,
            username: String::new(),
            password: String::new(),
            role: UserRole::Normal,
            star: 1,
            online_status: OnlineStatus::Offline,
            ban_status: BanStatus::Normal,
            // ... å…¶ä»–é»˜è®¤å€¼
        }
    }
}
```

## ğŸ”§ æœåŠ¡å±‚è®¾è®¡

### æœåŠ¡å±‚èŒè´£
1. **ä¸šåŠ¡é€»è¾‘å¤„ç†**: å¤æ‚çš„ä¸šåŠ¡è§„åˆ™
2. **æ•°æ®éªŒè¯**: ä¸šåŠ¡å±‚é¢çš„æ•°æ®éªŒè¯
3. **äº‹åŠ¡ç®¡ç†**: ç¡®ä¿æ•°æ®ä¸€è‡´æ€§
4. **é”™è¯¯å¤„ç†**: ç»Ÿä¸€çš„é”™è¯¯å¤„ç†é€»è¾‘

### æœåŠ¡å±‚å®ç°
```rust
pub struct UserService {
    user_repository: UserRepository,
    auth_core: AuthCore,
}

impl UserService {
    pub async fn register(&self, request: RegisterRequest) -> Result<ApiResponse<User>> {
        // 1. ä¸šåŠ¡éªŒè¯
        if self.auth_core.is_username_exists(&request.username).await? {
            return Err(anyhow::anyhow!("ç”¨æˆ·åå·²å­˜åœ¨"));
        }

        // 2. åˆ›å»ºç”¨æˆ·
        let user_id = self.auth_core.generate_user_id().await?;
        let new_user = User {
            id: user_id,
            username: request.username,
            password: request.password,
            // ... å…¶ä»–å­—æ®µ
        };

        // 3. ä¿å­˜æ•°æ®
        self.user_repository.create_user(&new_user).await?;
        
        // 4. è¿”å›ç»“æœ
        Ok(ApiResponse::success(new_user))
    }
}
```

## ğŸ›¡ï¸ ä¸­é—´ä»¶è®¾è®¡

### è®¤è¯ä¸­é—´ä»¶
```rust
pub struct AuthMiddleware {
    pub required_permissions: Vec<String>,
}

impl AuthMiddleware {
    pub fn require_auth() -> Self {
        Self { required_permissions: vec![] }
    }
    
    pub fn require_permission(permission: &str) -> Self {
        Self { required_permissions: vec![permission.to_string()] }
    }
}
```

### é™æµä¸­é—´ä»¶
```rust
pub struct RateLimitMiddleware {
    pub requests_per_minute: u32,
    pub burst_size: u32,
}

impl RateLimitMiddleware {
    pub fn new(requests_per_minute: u32, burst_size: u32) -> Self {
        Self { requests_per_minute, burst_size }
    }
}
```

## âŒ é”™è¯¯å¤„ç†

### ç»Ÿä¸€é”™è¯¯å“åº”
```rust
#[derive(Debug, Serialize, Deserialize)]
pub struct ApiResponse<T> {
    pub code: i32,
    pub message: String,
    pub data: Option<T>,
    pub timestamp: i64,
    pub request_id: Option<String>,
}

impl<T> ApiResponse<T> {
    pub fn success(data: T) -> Self {
        Self {
            code: 200,
            message: "æ“ä½œæˆåŠŸ".to_string(),
            data: Some(data),
            timestamp: chrono::Utc::now().timestamp(),
            request_id: None,
        }
    }
    
    pub fn error(code: i32, message: &str) -> Self {
        Self {
            code,
            message: message.to_string(),
            data: None,
            timestamp: chrono::Utc::now().timestamp(),
            request_id: None,
        }
    }
}
```

### é”™è¯¯ç è§„èŒƒ
```rust
pub mod error_codes {
    pub const SUCCESS: i32 = 200;
    pub const CREATED: i32 = 201;
    pub const BAD_REQUEST: i32 = 400;
    pub const UNAUTHORIZED: i32 = 401;
    pub const FORBIDDEN: i32 = 403;
    pub const NOT_FOUND: i32 = 404;
    pub const TOO_MANY_REQUESTS: i32 = 429;
    pub const INTERNAL_SERVER_ERROR: i32 = 500;
    
    // ä¸šåŠ¡é”™è¯¯ç  (1000-9999)
    pub const USER_NOT_FOUND: i32 = 1001;
    pub const INVALID_CREDENTIALS: i32 = 1002;
    pub const USER_ALREADY_EXISTS: i32 = 1003;
    pub const INSUFFICIENT_PERMISSIONS: i32 = 1004;
}
```

## ğŸ“ æ—¥å¿—è§„èŒƒ

### æ—¥å¿—çº§åˆ«
- **ERROR**: é”™è¯¯ä¿¡æ¯ï¼Œéœ€è¦ç«‹å³å¤„ç†
- **WARN**: è­¦å‘Šä¿¡æ¯ï¼Œéœ€è¦æ³¨æ„
- **INFO**: ä¸€èˆ¬ä¿¡æ¯ï¼Œè®°å½•é‡è¦æ“ä½œ
- **DEBUG**: è°ƒè¯•ä¿¡æ¯ï¼Œå¼€å‘æ—¶ä½¿ç”¨
- **TRACE**: è·Ÿè¸ªä¿¡æ¯ï¼Œè¯¦ç»†è°ƒè¯•

### æ—¥å¿—æ ¼å¼
```rust
use log::{info, error, warn, debug};

// è®°å½•APIè°ƒç”¨
info!(
    "APIè°ƒç”¨: {} {} - ç”¨æˆ·: {} - å“åº”æ—¶é—´: {}ms",
    method, path, username, response_time
);

// è®°å½•é”™è¯¯
error!(
    "æ“ä½œå¤±è´¥: {} - ç”¨æˆ·: {} - é”™è¯¯: {}",
    operation, username, error
);
```

### æ€§èƒ½ç›‘æ§
```rust
pub struct ApiCallRecord {
    pub timestamp: u64,
    pub api_name: String,
    pub username: String,
    pub ip_address: String,
    pub user_agent: String,
    pub response_time_ms: u64,
    pub status_code: u16,
    pub success: bool,
    pub error_message: Option<String>,
}
```

## ğŸ§ª æµ‹è¯•è§„èŒƒ

### å•å…ƒæµ‹è¯•
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_user_creation() {
        let user = User::new("test_user", "password");
        assert_eq!(user.username, "test_user");
        assert_eq!(user.role, UserRole::Normal);
    }
    
    #[test]
    fn test_user_validation() {
        let user = User::new("test", "pass");
        assert!(user.validate().is_ok());
    }
}
```

### é›†æˆæµ‹è¯•
```rust
#[actix_web::test]
async fn test_login_api() {
    let app = test::init_service(
        App::new()
            .configure(configure_routes)
    ).await;

    let req = test::TestRequest::post()
        .uri("/api/v1/auth/login")
        .set_json(json!({
            "username": "admin",
            "password": "admin123"
        }))
        .to_request();

    let resp = test::call_service(&app, req).await;
    assert!(resp.status().is_success());
}
```

### æ€§èƒ½æµ‹è¯•
```rust
use criterion::{criterion_group, criterion_main, Criterion};

fn benchmark_user_creation(c: &mut Criterion) {
    c.bench_function("create_user", |b| {
        b.iter(|| {
            // æµ‹è¯•ä»£ç 
        })
    });
}

criterion_group!(benches, benchmark_user_creation);
criterion_main!(benches);
```

## ğŸš€ éƒ¨ç½²è§„èŒƒ

### ç¯å¢ƒé…ç½®
```toml
# Cargo.toml
[package]
name = "ç»³åŒ…ç®¡ç†å™¨"
version = "0.1.0"
edition = "2021"

[dependencies]
actix-web = "4.4"
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
```

### Dockeréƒ¨ç½²
```dockerfile
FROM rust:1.70 as builder
WORKDIR /app
COPY . .
RUN cargo build --release

FROM debian:bullseye-slim
RUN apt-get update && apt-get install -y ca-certificates && rm -rf /var/lib/apt/lists/*
COPY --from=builder /app/target/release/ç»³åŒ…ç®¡ç†å™¨ /usr/local/bin/
EXPOSE 15201
CMD ["ç»³åŒ…ç®¡ç†å™¨"]
```

### ç›‘æ§æŒ‡æ ‡
1. **å“åº”æ—¶é—´**: å¹³å‡å“åº”æ—¶é—´ < 200ms
2. **é”™è¯¯ç‡**: é”™è¯¯ç‡ < 1%
3. **ååé‡**: QPS > 1000
4. **å¯ç”¨æ€§**: 99.9%

## ğŸ“š ä»£ç è§„èŒƒ

### å‘½åè§„èŒƒ
- **å‡½æ•°å**: ä½¿ç”¨snake_case
- **å˜é‡å**: ä½¿ç”¨snake_case
- **å¸¸é‡å**: ä½¿ç”¨SCREAMING_SNAKE_CASE
- **ç±»å‹å**: ä½¿ç”¨PascalCase
- **æ¨¡å—å**: ä½¿ç”¨snake_case

### æ³¨é‡Šè§„èŒƒ
```rust
/// ç”¨æˆ·æœåŠ¡
/// 
/// æä¾›ç”¨æˆ·ç›¸å…³çš„ä¸šåŠ¡é€»è¾‘å¤„ç†
pub struct UserService {
    user_repository: UserRepository,
    auth_core: AuthCore,
}

impl UserService {
    /// åˆ›å»ºæ–°ç”¨æˆ·
    /// 
    /// # Arguments
    /// * `request` - ç”¨æˆ·åˆ›å»ºè¯·æ±‚
    /// 
    /// # Returns
    /// * `Result<ApiResponse<User>>` - åˆ›å»ºç»“æœ
    /// 
    /// # Examples
    /// ```
    /// let user = service.create_user(request).await?;
    /// ```
    pub async fn create_user(&self, request: CreateUserRequest) -> Result<ApiResponse<User>> {
        // å®ç°ä»£ç 
    }
}
```

### é”™è¯¯å¤„ç†è§„èŒƒ
```rust
// ä½¿ç”¨Resultç±»å‹å¤„ç†é”™è¯¯
pub async fn get_user(id: u64) -> Result<User, Box<dyn std::error::Error>> {
    let users = data_manager.get_users()?;
    
    users
        .iter()
        .find(|u| u.id == id)
        .cloned()
        .ok_or_else(|| "ç”¨æˆ·ä¸å­˜åœ¨".into())
}
```

## ğŸ”„ ç‰ˆæœ¬æ§åˆ¶è§„èŒƒ

### APIç‰ˆæœ¬ç®¡ç†
- **v1**: å½“å‰ç¨³å®šç‰ˆæœ¬
- **v2**: å¼€å‘ä¸­çš„æ–°ç‰ˆæœ¬
- **v0**: å®éªŒæ€§åŠŸèƒ½

### å‘åå…¼å®¹æ€§
1. **æ–°å¢å­—æ®µ**: ä½¿ç”¨Optionç±»å‹
2. **åˆ é™¤å­—æ®µ**: æ ‡è®°ä¸ºdeprecated
3. **ä¿®æ”¹å­—æ®µ**: æä¾›è¿ç§»æ–¹æ¡ˆ

### ç‰ˆæœ¬è¿ç§»ç­–ç•¥
1. **æ¸è¿›å¼è¿ç§»**: åŒæ—¶æ”¯æŒå¤šä¸ªç‰ˆæœ¬
2. **å¼ºåˆ¶å‡çº§**: è®¾ç½®ç‰ˆæœ¬è¿‡æœŸæ—¶é—´
3. **è‡ªåŠ¨å‡çº§**: æä¾›å‡çº§å·¥å…·

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–è§„èŒƒ

### æ•°æ®åº“ä¼˜åŒ–
1. **ç´¢å¼•ä¼˜åŒ–**: ä¸ºå¸¸ç”¨æŸ¥è¯¢å­—æ®µåˆ›å»ºç´¢å¼•
2. **æŸ¥è¯¢ä¼˜åŒ–**: é¿å…N+1æŸ¥è¯¢é—®é¢˜
3. **è¿æ¥æ± **: ä½¿ç”¨æ•°æ®åº“è¿æ¥æ± 
4. **ç¼“å­˜**: å¯¹çƒ­ç‚¹æ•°æ®è¿›è¡Œç¼“å­˜
5. **æ•°æ®åº“**: æ•°æ®åº“ä½¿ç”¨   QSL

### ç¼“å­˜ç­–ç•¥
```rust
// Redisç¼“å­˜é”®å‘½åè§„èŒƒ
// ç”¨æˆ·ä¿¡æ¯: user:{id}
// ç»³åŒ…åˆ—è¡¨: packages:list:{page}:{size}
// ç»Ÿè®¡æ•°æ®: stats:daily:{date}
```

### å¼‚æ­¥å¤„ç†
```rust
// ä½¿ç”¨å¼‚æ­¥å¤„ç†æé«˜æ€§èƒ½
pub async fn process_user_data(&self, user_id: u64) -> Result<()> {
    let user = self.get_user(user_id).await?;
    let processed_data = self.process_data(user).await?;
    self.save_data(processed_data).await?;
    Ok(())
}
```

## ğŸ”’ å®‰å…¨è§„èŒƒ

### è®¤è¯å®‰å…¨
1. **å¯†ç åŠ å¯†**: ä½¿ç”¨bcryptåŠ å¯†å¯†ç 
2. **JWT Token**: ä½¿ç”¨å®‰å…¨çš„JWTå®ç°
3. **Sessionç®¡ç†**: å®‰å…¨çš„sessionç®¡ç†
4. **æƒé™æ§åˆ¶**: ç»†ç²’åº¦çš„æƒé™æ§åˆ¶

### æ•°æ®å®‰å…¨
1. **è¾“å…¥éªŒè¯**: ä¸¥æ ¼éªŒè¯æ‰€æœ‰è¾“å…¥
2. **SQLæ³¨å…¥é˜²æŠ¤**: ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
3. **XSSé˜²æŠ¤**: è¾“å‡ºè½¬ä¹‰
4. **CSRFé˜²æŠ¤**: CSRF tokenéªŒè¯

### ç½‘ç»œå®‰å…¨
1. **HTTPS**: å¼ºåˆ¶ä½¿ç”¨HTTPS
2. **CORSé…ç½®**: æ­£ç¡®é…ç½®CORS
3. **é™æµ**: é˜²æ­¢DDoSæ”»å‡»
4. **æ—¥å¿—å®‰å…¨**: ä¸è®°å½•æ•æ„Ÿä¿¡æ¯

## ğŸ“Š ç›‘æ§è§„èŒƒ

### åº”ç”¨ç›‘æ§
1. **å¥åº·æ£€æŸ¥**: `/health` ç«¯ç‚¹
2. **æ€§èƒ½ç›‘æ§**: å“åº”æ—¶é—´ã€ååé‡
3. **é”™è¯¯ç›‘æ§**: é”™è¯¯ç‡ã€é”™è¯¯ç±»å‹
4. **èµ„æºç›‘æ§**: CPUã€å†…å­˜ã€ç£ç›˜

### ä¸šåŠ¡ç›‘æ§
1. **ç”¨æˆ·æ´»è·ƒåº¦**: æ—¥æ´»ã€æœˆæ´»ç”¨æˆ·
2. **åŠŸèƒ½ä½¿ç”¨ç‡**: å„åŠŸèƒ½ä½¿ç”¨æƒ…å†µ
3. **æ•°æ®ç»Ÿè®¡**: ç”¨æˆ·å¢é•¿ã€å†…å®¹å¢é•¿
4. **å¼‚å¸¸ç›‘æ§**: å¼‚å¸¸è¡Œä¸ºæ£€æµ‹

## ğŸ¯ å¼€å‘æµç¨‹è§„èŒƒ

### ä»£ç å®¡æŸ¥
1. **åŠŸèƒ½å®Œæ•´æ€§**: åŠŸèƒ½æ˜¯å¦å®Œæ•´
2. **ä»£ç è´¨é‡**: ä»£ç æ˜¯å¦è§„èŒƒ
3. **æ€§èƒ½å½±å“**: æ˜¯å¦å½±å“æ€§èƒ½
4. **å®‰å…¨é£é™©**: æ˜¯å¦å­˜åœ¨å®‰å…¨é£é™©

### æµ‹è¯•æµç¨‹
1. **å•å…ƒæµ‹è¯•**: è¦†ç›–æ ¸å¿ƒé€»è¾‘
2. **é›†æˆæµ‹è¯•**: æµ‹è¯•APIæ¥å£
3. **æ€§èƒ½æµ‹è¯•**: æµ‹è¯•æ€§èƒ½æŒ‡æ ‡
4. **å®‰å…¨æµ‹è¯•**: æµ‹è¯•å®‰å…¨æ¼æ´

### éƒ¨ç½²æµç¨‹
1. **ä»£ç æ„å»º**: è‡ªåŠ¨åŒ–æ„å»º
2. **æµ‹è¯•éªŒè¯**: è‡ªåŠ¨åŒ–æµ‹è¯•
3. **éƒ¨ç½²å‘å¸ƒ**: è‡ªåŠ¨åŒ–éƒ¨ç½²
4. **ç›‘æ§éªŒè¯**: éƒ¨ç½²åç›‘æ§
